#!/usr/bin/env node
import { readdir, writeFile } from 'node:fs/promises'
import { join, relative, parse } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const componentsDir = join(__dirname, '../src/runtime/components')
const controlsDir = join(__dirname, '../src/runtime/controls')
const outputFile = join(__dirname, '../src/runtime/components.d.ts')

// Convert filename to PascalCase component name with prefix
function toPascalCase (str: string): string {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
}

function getComponentName (filePath: string, prefix: string, includePathPrefix: boolean): string {
  const parsed = parse(filePath)
  const dir = parsed.dir
  const name = parsed.name

  // Remove .client or .server suffix
  const cleanName = name.replace(/\.(client|server)$/, '')

  // Build the component name
  let componentName = prefix

  if (includePathPrefix && dir) {
    // Add directory path as part of the name (e.g., admin/user-form -> TlAdminUserForm)
    const dirParts = dir.split('/').filter(Boolean)
    componentName += dirParts.map(toPascalCase).join('')
  }

  componentName += toPascalCase(cleanName)

  return componentName
}

async function* walk (dir: string, basePath: string = ''): AsyncGenerator<string> {
  const entries = await readdir(dir, { withFileTypes: true })

  for (const entry of entries) {
    const fullPath = join(dir, entry.name)
    const relativePath = basePath ? join(basePath, entry.name) : entry.name

    if (entry.isDirectory()) {
      yield* walk(fullPath, relativePath)
    } else if (entry.isFile() && entry.name.endsWith('.vue')) {
      yield relativePath
    }
  }
}

async function generateComponentTypes () {
  const components: string[] = []
  const controls: string[] = []

  // Collect all .vue files from components
  for await (const filePath of walk(componentsDir)) {
    components.push(filePath)
  }

  // Collect all .vue files from controls
  for await (const filePath of walk(controlsDir)) {
    controls.push(filePath)
  }

  // Sort for consistent output
  components.sort()
  controls.sort()

  // Generate type declarations for components (Tl prefix)
  const componentTypeDeclarations = components.map((filePath) => {
    const componentName = getComponentName(filePath, 'Tl', true)
    const importPath = `./components/${filePath.replace(/\\/g, '/')}`
    return `    ${componentName}: typeof import('${importPath}')['default']`
  }).join('\n')

  // Generate type declarations for controls (T prefix)
  const controlTypeDeclarations = controls.map((filePath) => {
    const parsed = parse(filePath)
    const name = parsed.name
    // Remove .client or .server suffix
    const cleanName = name.replace(/\.(client|server)$/, '')
    const componentName = 'T' + toPascalCase(cleanName)
    const importPath = `./controls/${filePath.replace(/\\/g, '/')}`
    return `    ${componentName}: typeof import('${importPath}')['default']`
  }).join('\n')

  const typeDeclarations = [componentTypeDeclarations, controlTypeDeclarations].filter(Boolean).join('\n')

  const output = `// Auto-generated by scripts/generate-component-types.ts
// Do not edit this file manually

// Declare global component types for strict template type checking
declare module 'vue' {
  export interface GlobalComponents {
${typeDeclarations}
  }
}

export {}
`

  await writeFile(outputFile, output, 'utf-8')
  console.log(`‚úÖ Generated component types for ${components.length} components and ${controls.length} controls`)
  console.log(`üìù Output: ${relative(process.cwd(), outputFile)}`)
}

generateComponentTypes().catch(console.error)
